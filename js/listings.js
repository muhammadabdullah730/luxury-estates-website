/**
 * Real Estate Website - Listings Page Functionality
 * Property listings grid, filters, and pagination
 * Generated by AI on 2023-11-15
 */

document.addEventListener('DOMContentLoaded', function() {
  // Only run on listings page
  if (!document.querySelector('.listings-results')) return;
  
  // Get URL parameters
  const urlParams = getUrlParams();
  
  // Initialize filters with URL parameters
  initFilters(urlParams);
  
  // Apply initial filters and render results
  applyFilters();
  
  // Initialize view toggle
  initViewToggle();
  
  // Initialize sorting
  initSorting();
  
  // Initialize filter form submission
  const filterForm = document.querySelector('#filters-form');
  if (filterForm) {
    filterForm.addEventListener('submit', function(e) {
      e.preventDefault();
      applyFilters();
    });
    
    // Add real-time filtering for certain inputs
    filterForm.querySelectorAll('input[type="text"], input[type="range"], select').forEach(input => {
      input.addEventListener('change', applyFilters);
    });
    
    filterForm.querySelectorAll('input[type="checkbox"]').forEach(input => {
      input.addEventListener('change', applyFilters);
    });
  }
  
  // Initialize price range slider
  initPriceRange();
});

/**
 * Initialize filter controls with URL parameters
 */
function initFilters(params) {
  // Location
  if (params.location) {
    const locationInput = document.querySelector('#filter-location');
    if (locationInput) locationInput.value = params.location;
  }
  
  // Type
  if (params.type) {
    const typeSelect = document.querySelector('#filter-type');
    if (typeSelect) typeSelect.value = params.type;
  }
  
  // Price range
  if (params.minPrice || params.maxPrice) {
    const minPriceInput = document.querySelector('#filter-min-price');
    const maxPriceInput = document.querySelector('#filter-max-price');
    
    if (minPriceInput && params.minPrice) minPriceInput.value = params.minPrice;
    if (maxPriceInput && params.maxPrice) maxPriceInput.value = params.maxPrice;
  }
  
  // Bedrooms
  if (params.bedrooms) {
    const bedroomsInput = document.querySelector(`#filter-bedrooms-${params.bedrooms}`);
    if (bedroomsInput) bedroomsInput.checked = true;
  }
  
  // Features
  if (params.features) {
    const features = Array.isArray(params.features) ? params.features : [params.features];
    
    features.forEach(feature => {
      const featureInput = document.querySelector(`#filter-feature-${feature.toLowerCase().replace(' ', '-')}`);
      if (featureInput) featureInput.checked = true;
    });
  }
}

/**
 * Apply current filters and render results
 */
function applyFilters() {
  // Get current filter values
  const filters = {
    location: document.querySelector('#filter-location')?.value,
    type: document.querySelector('#filter-type')?.value,
    minPrice: document.querySelector('#filter-min-price')?.value,
    maxPrice: document.querySelector('#filter-max-price')?.value,
    bedrooms: document.querySelector('input[name="bedrooms"]:checked')?.value,
    features: Array.from(document.querySelectorAll('input[name="features"]:checked')).map(el => el.value)
  };
  
  // Filter properties
  let filteredProperties = filterProperties(filters);
  
  // Get current sort value
  const sortBy = document.querySelector('#sort-by')?.value;
  
  // Sort properties
  filteredProperties = sortProperties(filteredProperties, sortBy);
  
  // Get current view mode
  const viewMode = document.querySelector('.view-btn.active')?.dataset.view || 'grid';
  
  // Render results
  renderResults(filteredProperties, viewMode);
  
  // Update results count
  updateResultsCount(filteredProperties.length);
  
  // Update URL without reloading
  updateUrlParams(filters);
}

/**
 * Render property results
 */
function renderResults(properties, viewMode = 'grid') {
  const resultsContainer = document.querySelector('.listings-results');
  const emptyState = document.querySelector('.listings-empty');
  
  if (properties.length === 0) {
    resultsContainer.innerHTML = '';
    if (emptyState) emptyState.style.display = 'block';
    return;
  }
  
  if (emptyState) emptyState.style.display = 'none';
  
  // Clear previous results
  resultsContainer.innerHTML = '';
  
  // Create property cards
  properties.forEach(property => {
    const card = createPropertyCard(property, viewMode);
    resultsContainer.appendChild(card);
  });
  
  // Re-initialize favorite buttons
  initFavorites();
}

/**
 * Create a property card element
 */
function createPropertyCard(property, viewMode = 'grid') {
  const isFavoriteClass = isFavorite(property.id) ? 'active' : '';
  
  if (viewMode === 'list') {
    const card = document.createElement('div');
    card.className = 'card card-list';
    card.innerHTML = `
      <div class="card-list-inner">
        <div class="card-list-img">
          <img src="${property.images[0]}" alt="${property.title}" loading="lazy">
          <button class="favorite-btn ${isFavoriteClass}" data-id="${property.id}">
            <i class="fas fa-heart"></i>
          </button>
        </div>
        <div class="card-list-body">
          <div class="card-list-header">
            <h3 class="card-title">${property.title}</h3>
            <p class="card-location">
              <i class="fas fa-map-marker-alt"></i>
              ${property.location.area}, ${property.location.city}
            </p>
          </div>
          <div class="card-list-details">
            <div class="card-meta">
              <div class="card-meta-item">
                <i class="fas fa-bed"></i>
                ${property.bedrooms} Beds
              </div>
              <div class="card-meta-item">
                <i class="fas fa-bath"></i>
                ${property.bathrooms} Baths
              </div>
              <div class="card-meta-item">
                <i class="fas fa-ruler-combined"></i>
                ${property.area_sqft.toLocaleString()} sqft
              </div>
            </div>
            <p class="card-text">${property.description.substring(0, 150)}...</p>
          </div>
          <div class="card-list-footer">
            <div class="card-price">${formatPrice(property.price, property.currency)}</div>
            <a href="property.html?id=${property.id}" class="btn btn-outline">View Details</a>
          </div>
        </div>
      </div>
    `;
    return card;
  }
  
  // Default grid view
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
    <img src="${property.images[0]}" class="card-img" alt="${property.title}" loading="lazy">
    <div class="card-body">
      <div class="card-header">
        <h3 class="card-title">${property.title}</h3>
        <p class="card-location">
          <i class="fas fa-map-marker-alt"></i>
          ${property.location.area}, ${property.location.city}
        </p>
      </div>
      <div class="card-meta">
        <div class="card-meta-item">
          <i class="fas fa-bed"></i>
          ${property.bedrooms} Beds
        </div>
        <div class="card-meta-item">
          <i class="fas fa-bath"></i>
          ${property.bathrooms} Baths
        </div>
        <div class="card-meta-item">
          <i class="fas fa-ruler-combined"></i>
          ${property.area_sqft.toLocaleString()} sqft
        </div>
      </div>
      <div class="features">
        ${property.features.slice(0, 3).map(feature => `
          <span class="feature">
            <i class="fas fa-check"></i>
            ${feature}
          </span>
        `).join('')}
      </div>
    </div>
    <div class="card-footer">
      <div class="card-price">${formatPrice(property.price, property.currency)}</div>
      <div class="card-actions">
        <button class="favorite-btn ${isFavoriteClass}" data-id="${property.id}">
          <i class="fas fa-heart"></i>
        </button>
        <a href="property.html?id=${property.id}" class="btn btn-sm btn-outline">Details</a>
      </div>
    </div>
  `;
  return card;
}

/**
 * Update results count display
 */
function updateResultsCount(count) {
  const countElement = document.querySelector('.listings-count');
  if (countElement) {
    countElement.textContent = `${count} ${count === 1 ? 'Property' : 'Properties'} Found`;
  }
}

/**
 * Update URL parameters without reloading
 */
function updateUrlParams(filters) {
  const params = new URLSearchParams();
  
  if (filters.location) params.append('location', filters.location);
  if (filters.type) params.append('type', filters.type);
  if (filters.minPrice) params.append('minPrice', filters.minPrice);
  if (filters.maxPrice) params.append('maxPrice', filters.maxPrice);
  if (filters.bedrooms) params.append('bedrooms', filters.bedrooms);
  if (filters.features && filters.features.length > 0) {
    filters.features.forEach(feature => params.append('features', feature));
  }
  
  window.history.replaceState(null, null, `?${params.toString()}`);
}

/**
 * Initialize view toggle (grid/list)
 */
function initViewToggle() {
  const viewBtns = document.querySelectorAll('.view-btn');
  
  viewBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      viewBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      const viewMode = this.dataset.view;
      const resultsContainer = document.querySelector('.listings-results');
      
      if (resultsContainer) {
        const currentProperties = Array.from(resultsContainer.children).map(card => {
          return PROPERTIES.find(p => p.id === card.querySelector('.favorite-btn')?.dataset.id);
        }).filter(Boolean);
        
        renderResults(currentProperties, viewMode);
      }
    });
  });
}

/**
 * Initialize sorting dropdown
 */
function initSorting() {
  const sortSelect = document.querySelector('#sort-by');
  if (sortSelect) {
    sortSelect.addEventListener('change', applyFilters);
  }
}

/**
 * Initialize price range slider
 */
function initPriceRange() {
  const minPriceInput = document.querySelector('#filter-min-price');
  const maxPriceInput = document.querySelector('#filter-max-price');
  const rangeSlider = document.querySelector('#price-range');
  
  if (!rangeSlider || !minPriceInput || !maxPriceInput) return;
  
  // Get min and max prices from all properties
  const prices = PROPERTIES.map(p => p.price);
  const minPrice = Math.min(...prices);
  const maxPrice = Math.max(...prices);
  
  // Set initial values
  minPriceInput.min = minPrice;
  minPriceInput.max = maxPrice;
  maxPriceInput.min = minPrice;
  maxPriceInput.max = maxPrice;
  
  // Initialize noUiSlider
  noUiSlider.create(rangeSlider, {
    start: [minPrice, maxPrice],
    connect: true,
    range: {
      'min': minPrice,
      'max': maxPrice
    },
    step: 10000,
    format: {
      to: function(value) {
        return Math.round(value);
      },
      from: function(value) {
        return Number(value);
      }
    }
  });
  
  // Update input fields when slider changes
  rangeSlider.noUiSlider.on('update', function(values, handle) {
    const value = values[handle];
    if (handle) {
      maxPriceInput.value = value;
    } else {
      minPriceInput.value = value;
    }
  });
  
  // Update slider when input fields change
  minPriceInput.addEventListener('change', function() {
    rangeSlider.noUiSlider.set([this.value, null]);
    applyFilters();
  });
  
  maxPriceInput.addEventListener('change', function() {
    rangeSlider.noUiSlider.set([null, this.value]);
    applyFilters();
  });
  
  // Add preset buttons
  document.querySelectorAll('.price-preset').forEach(btn => {
    btn.addEventListener('click', function() {
      const preset = this.dataset.preset;
      let min, max;
      
      switch (preset) {
        case 'under-500k':
          min = minPrice;
          max = 500000;
          break;
        case '500k-1m':
          min = 500000;
          max = 1000000;
          break;
        case '1m-2m':
          min = 1000000;
          max = 2000000;
          break;
        case 'over-2m':
          min = 2000000;
          max = maxPrice;
          break;
        default:
          min = minPrice;
          max = maxPrice;
      }
      
      rangeSlider.noUiSlider.set([min, max]);
      minPriceInput.value = min;
      maxPriceInput.value = max;
      applyFilters();
    });
  });
}